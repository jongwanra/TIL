# Chapter08. 의존성 관리하기

## 01. 의존성 이해하기

### 변경과 의존성

협력을 위해서 다른 객체를 필요로 하게 되면 의존성이 존재하게 된다.
의존성은 시점에 따라 다른 의미를 가진다.

* 실행 시점
  * 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
* 구현 시점
  * 의존 대상 객체가 변경될 경우 의존 하는 객체 역시 변경될 가능성이 있다.

```java
public class Member {
	private Team team;
	private String name;
}
```

위에 예시를 통해서 봤을 떄, Member는 Team에 대해 의존성을 가지고 있으며 Team의 className이 변경될 경우 Member 역시 같이 변경하게 된다.  
의존성은 Member -> Team을 의존하는 것과 같이 단방향으로 흐른다. 즉, Team이 변경 될 경우, Member도 변경될 가능성이 존재하지만 그 역은 존재하지 않는다.


### 의존성 전이

A 객체가 B객체를 의존하고 있고, B객체가 C객체를 의존하고 있을 경우, C객체가 변경될 경우 간접적으로 A 객체 역시 변경될 가능성이 있는 것을 의존성 전이라고 한다.  
A 객체가 B객체를 의존하거나, B 객체가 C객체를 의존하는 경우를 직접 의존성이라고 부르며 A 객체가 간접적으로 C객체를 의존하고 있는 것을 간접 의존성이라고 부른다.  
여기서는 Class 단위로 설명했지만 의존성이라는 것은 모듈 기준이 될 수 있고, 시스템 기준이 될 수 있다.    
**의존성이란 의존 대상 객체가 변경되었을 때 의존하는 객체도 변경될 수 있는 가능성을 의미한다.**

### 런타임 의존성과 컴파일타임 의존성
의존성을 시점에 따라 런타임과 컴파일 타임 의존성으로도 나눌 수 있다.  
런타임 의존성은 말그대로 프로그램을 실행시켰을 때의 의존성을 말한다. 하지만 컴파일 타임 의존성은 문맥에 따라 컴파일을 하고 난 직후를 의미할 수도 있고 단순히 코드를 의미할 수 있다.  
런타임 의존성의 주체는 객체이고 컴파일타임 의존성의 주체는 클래스를 이야기 한다.  

객체 간의 협력 관계가 런타임 시, 컴파일 타임 시점에 다를 수 있으며 다를수록 설계가 유연해지고 재사용이 가능해진다. 

### 컨텍스트 독립성

런타임 의존성과 컴파일타임 의존성을 다르게 가져감으로써 설계시 더 유연해지고 재사용이 가능해진다.  
문맥적으로 강하게 결합시키는 것이 아닌 서로 간의 객체가 최소한의 행위만을 가지고 협력하며 각 객체가 의존하고 있는 객체에 대해 알지 못하게 하는 것을 `컨텍스트 독립적`이라고 한다. 
이렇게 컨텍스트 독립적으로 구현하게 된다면 다른 문맥에서 원활한 재사용이 가능해진다.

### 의존성 해결하기

`의존성 해결`은 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체하는 것을 의미한다.  

의존성 해결을 하기 위한 방법은 총 3가지이다.
* 생성자의 인자를 통해 주입하는 법
* setter method 인자를 통해 주입하는 법
* 특정 메서드 호출 시에 인자로 주입하는 법

setter방식으로 의존성 해결을 할 경우에는 시스템 적으로 불안전할 수 있다는 단점이 존재한다.  
따라서 생성자를 통해 default를 주입하며, 필요시 setter method를 통해 다양하게 문맥적으로 활용하는 방식이 선호된다.


## 02. 유연한 설계

### 의존성과 결합도

의존성은 존재의 유무를 나타낼 떄 사용한다. 의존성이 존재한다. 의존성이 존재하지 않는다 등..  
결합도는 의존성의 정도를 나타낼 때 사용한다. 결합도가 높다, 결합도가 낮다 등..  

의존성은 협력을 근간으로 하는 객체 지향 패러다임의 관점에서 꼭 필요하다. 하지만 바람직한 의존성과 바람직하지 않은 의존성이 존재한다.  
여기서 바람직한 의존성은 재사용성과 관련이 있다. 다른 모듈 혹은 클래스 등에서도 재사용이 가능한지에 따라 바람직하다 혹은 바람직하지 않은 의존성으로 표현할 수 있다.  
의존성이 바람직할 때 결합도가 느슨하다고 표현할 수 있고, 의존성이 바람직하지 않을 떄 결합도가 강하다, 단단하다로 표현할 수 있다.


### 지식이 결합을 낳는다

결합도를 느슨하게 만드는 것이 중요하다.  
결합도를 느슨하게 만든다는 것은 의존 대상 객체에 대해서 최대한 아는 정도를 낮추는 것을 의미한다.  
즉 감춰야 한다.  
결합도를 느슨하게 만드는 방법은 `추상화`다.


### 추상화에 의존하라

추상화란 필요한 부분을 명확하게 이해하기 위해서 불필요한 부분을 감추어 복잡도를 극복하는 방법이다.  구체 클래스에 의존을 하게 되면 그 만큼 의존 대상에 대해 아는 정보가 많아지기 떄문에 강하게 결합될 수 밖에 없다. 따라서 추상 클래스 더 나아가 인터페이스를 의존하게 함으로써 느슨한 결합을 줄 수 있다.  
의존하는 대상이 추상적일 수록 결합도는 느슨해 진다.

### 명시적인 의존성

필자는 퍼블릭 인터페이스를 통해 의존성을 명시적으로 드러내야 한다고 이야기한다.  
퍼블릭 인터페이스를 통해 의존성을 명시적으로 드러내지 않고 숨길 경우 내부의 의존성을 찾아야 하는 번거러움이 생기기 떄문이다.  더 큰 문제는 
다른 클래스에서 재사용하려고 할 때 명시적이지 않은 의존성으로 인해 클래스 내부를 직접 변경해야 하는 문제가 발생한다.  

### new는 해롭다

new 연산자를 통해서 객체를 생성하는 것은 해롭다.  
해로운 이유는 new 연산자는 구체 클래스에서만 사용이 가능하기 때문에 의존하는 객체가 구체 클래스에 의존하게 되어버리면서 단단하게 결합된다.  
뿐만 아니라 생성자의 인자로 전달되는 값들에 대해서도 의존하는 객체가 알게되어 버린다. 따라서 new는 해롭다.

### 가끔은 생성해도 무방하다

많은 빈도로 사용하고 있는 의존 대상 구체 클래스라고 한다면 기본 값으로 생성자에서 구체 클래스를 생성하는 방법으로 활용할 수 있다.  
결국에는 결합도와 사용성의 트레이드 오프이다. 

### 표준 클래스에 대한 의존은 해롭지 않다.

```java

public abstract class DiscountPolicy {
	private List<DiscountCondition> conditions = new ArrayList<>();
}
```

자바에서 제공하는 표준 클래스인 ArrayList의 변경 가능성은 0에 가깝다.  
따라서 구체 클래스에 의존하더라도 변경시 영향이 거의 0에 가깝기 때문에 의존성이 문제가 되지 않는다.  

비록 클래스를 직접 생성하더라도 가능한 한 추상적인 타입을 사용하는 것이 확장성 측면에선 유리하다.


### 컨텍스트 확장하기

NoneDiscountPolicy, OverappedDiscountPolicy 등을 구체 클래스를 추가해서 내부 로직을 변경하는 것이 아닌   
기존의 DiscountPolicy를 확장해서 사용하였다. 


### 조합 가능한 행동



 








