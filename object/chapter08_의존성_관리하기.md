# Chapter08. 의존성 관리하기

## 01. 의존성 이해하기

### 변경과 의존성

협력을 위해서 다른 객체를 필요로 하게 되면 의존성이 존재하게 된다.
의존성은 시점에 따라 다른 의미를 가진다.

* 실행 시점
  * 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
* 구현 시점
  * 의존 대상 객체가 변경될 경우 의존 하는 객체 역시 변경될 가능성이 있다.

```java
public class Member {
	private Team team;
	private String name;
}
```

위에 예시를 통해서 봤을 떄, Member는 Team에 대해 의존성을 가지고 있으며 Team의 className이 변경될 경우 Member 역시 같이 변경하게 된다.  
의존성은 Member -> Team을 의존하는 것과 같이 단방향으로 흐른다. 즉, Team이 변경 될 경우, Member도 변경될 가능성이 존재하지만 그 역은 존재하지 않는다.


### 의존성 전이

A 객체가 B객체를 의존하고 있고, B객체가 C객체를 의존하고 있을 경우, C객체가 변경될 경우 간접적으로 A 객체 역시 변경될 가능성이 있는 것을 의존성 전이라고 한다.  
A 객체가 B객체를 의존하거나, B 객체가 C객체를 의존하는 경우를 직접 의존성이라고 부르며 A 객체가 간접적으로 C객체를 의존하고 있는 것을 간접 의존성이라고 부른다.  
여기서는 Class 단위로 설명했지만 의존성이라는 것은 모듈 기준이 될 수 있고, 시스템 기준이 될 수 있다.    
**의존성이란 의존 대상 객체가 변경되었을 때 의존하는 객체도 변경될 수 있는 가능성을 의미한다.**

### 런타임 의존성과 컴파일타임 의존성
의존성을 시점에 따라 런타임과 컴파일 타임 의존성으로도 나눌 수 있다.  
런타임 의존성은 말그대로 프로그램을 실행시켰을 때의 의존성을 말한다. 하지만 컴파일 타임 의존성은 문맥에 따라 컴파일을 하고 난 직후를 의미할 수도 있고 단순히 코드를 의미할 수 있다.  
런타임 의존성의 주체는 객체이고 컴파일타임 의존성의 주체는 클래스를 이야기 한다.  

객체 간의 협력 관계가 런타임 시, 컴파일 타임 시점에 다를 수 있으며 다를수록 설계가 유연해지고 재사용이 가능해진다. 

### 컨텍스트 독립성

런타임 의존성과 컴파일타임 의존성을 다르게 가져감으로써 설계시 더 유연해지고 재사용이 가능해진다.  
문맥적으로 강하게 결합시키는 것이 아닌 서로 간의 객체가 최소한의 행위만을 가지고 협력하며 각 객체가 의존하고 있는 객체에 대해 알지 못하게 하는 것을 `컨텍스트 독립적`이라고 한다. 
이렇게 컨텍스트 독립적으로 구현하게 된다면 다른 문맥에서 원활한 재사용이 가능해진다.

### 의존성 해결하기

`의존성 해결`은 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체하는 것을 의미한다.  

의존성 해결을 하기 위한 방법은 총 3가지이다.
* 생성자의 인자를 통해 주입하는 법
* setter method 인자를 통해 주입하는 법
* 특정 메서드 호출 시에 인자로 주입하는 법

setter방식으로 의존성 해결을 할 경우에는 시스템 적으로 불안전할 수 있다는 단점이 존재한다.  
따라서 생성자를 통해 default를 주입하며, 필요시 setter method를 통해 다양하게 문맥적으로 활용하는 방식이 선호된다.


## 02. 유연한 설계


 








