# Chapter02. 객체지향 프로그래밍

## 02. 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

객체 지향은 객체를 지향하는 것이다.  
하지만 대부분의 사람들은 클래스를 먼저 생각하고 어떤 속성과 메서드가 필요한지를 고민한다.  
설계 시, 클래스가 아닌 객체에 초점을 맞추자. 이를 위해 다음 두 가지에 집중하자.  

1. 클래스를 고민하기 전에 어떤 객체들이 필요한지를 고민하자. 
2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 바라보자.

### 도메인의 구조를 따르는 프로그램 구조

문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인**이라고 부른다.


## 04. 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

컴파일 시점의 의존성과 실행 시점의 의존성은 서로 다를 수 있다. 다시 말해서 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.  
컴파일 시점의 의존성과 실행 시점의 의존성이 다르면 다를 수록 이해하기 어려워지며, 코드는 유연해지고 확장 가능해진다.(의존성의 양면성)  

유연성과 가독성 사이에서 고민해야 한다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다. 


### 차이에 의한 프로그래밍

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 차이에 의한 프로그래밍(programming by difference)이라고 부른다.


### 상속과 인터페이스

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한다는 것을 기억하자.  
상속을 통해 자식 클래스는 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하게 된다.

### 다형성

다형성은 객체지향 프로그램의 컴파일 시점 의존성과 실행 시점 의존성이 다를 수 있다는 사실을 기반으로 한다.  


## 05. 추상화와 유연성

### 유연한 설계

추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다.  
유연성이 필요한 곳에 추상화를 사용하라.


### 추상 클래스와 인터페이스 트레이드오프

구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다.  
작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사소한 결정이더라도 트레이드오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.  
고민하고 트레이드오프하라.


### 코드 재사용

상속은 코드를 재사용하기 위해 널리 사용되는 방법이다.  
그러나 가장 좋은 방법인 것은 아니다. 코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이라는 이야기를 많이 들었을 것이다.


### 상속

상속은 두 가지 관점에서 설계에 안 좋은 영향을 미친다.
1. 캡슐화 위반(강한 결합)
    * 결과적으로 상위 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.
    * 캡슐화의 약화는 하위 클래스가 상위 클래스에 강하게 결합되도록 만들기 때문에 상위 클래스를 변경할 때 하위 클래스도 함께 변경될 확률을 높인다. 
    * 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.
2. 설계를 유연하지 못하게 한다.
   * 상속은 상위 클래스와 하위 클래스 사이의 관계를 **컴파일 시점에 결정한다.** 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.

### 합성
합성은 상속과 달리 인터페이스를 통해 약하게 결합된다.  
이처럼 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법을 **합성**이라고 한다.  
합성은 상속이 가지는 두 가지 문제점을 모두 해결한다.

1. 효과적으로 캡슐화 할 수 있다.
2. 설계를 유연하게 만든다. 

따라서 상속보다는 합성을 선호하는 것이 더 좋은 방법이다.
